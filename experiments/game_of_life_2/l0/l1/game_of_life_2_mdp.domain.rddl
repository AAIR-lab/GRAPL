////////////////////////////////////////////////////////////////////
// Game of Life Boolean POMDP
//
// A simple DBN to encode Conway's cellular automata "game of life" 
// on a grid.  One gets a reward for generating patterns that keep 
// the most cells alive.
//
// Author: Scott Sanner (ssanner [at] gmail.com)
////////////////////////////////////////////////////////////////////
domain game_of_life_2_mdp {
  	
	requirements = { reward-deterministic };

	types {
		location : object;
	};
      	
	pvariables { 
		NOISE-PROB(location) : { non-fluent, real, default = 0.1 };
		NEIGHBOR(location, location) : { non-fluent, bool, default = false };
		alive(location) : { state-fluent,  bool, default = false };
		set(location)   : { action-fluent, bool, default = false };
	};
  
	cpfs {
		// Conway's game of life rules (from Wikipedia):
		// 1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.
   		// 2. Any live cell with more than three live neighbors dies, as if by overcrowding.
   		// 3. Any live cell with two or three live neighbors lives on to the next generation.
   		// 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
   		//
   		// For interactivity: we allow an agent to explicitly set different cells.
		
		alive'(?l1) = 
			if ([alive(?l1) ^ ([sum_{?l2 : location} NEIGHBOR(?l1,?l2) ^ alive(?l2)] >= 2) 
							^ ([sum_{?l2 : location} NEIGHBOR(?l1,?l2) ^ alive(?l2)] <= 3)]
						| [~alive(?l1) ^ ([sum_{?l2 : location} NEIGHBOR(?l1,?l2) ^ alive(?l2)] == 3)]
						| set(?l1))
			then Bernoulli(1.0 - NOISE-PROB(?l1))
			else Bernoulli(NOISE-PROB(?l1));
	};
    	
	reward = sum_{?l1 : location} [alive(?l1) - set(?l1)];
    	
    state-action-constraints {
    	forall_{?l1 : location}
    		[(NOISE-PROB(?l1) >= 0.0) ^ (NOISE-PROB(?l1) <= 1.0)];
    };
}

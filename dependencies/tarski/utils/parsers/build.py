#!/usr/bin/env python3
"""
 Helper script to generate the parser from the ANTLR grammar.

 Essentially this invokes ANTLR on the required grammars, performs a few name changes and moves the generated
 files to the Tarski source tree. This should be invoked to generate the AST tree parser only when changes
 to the grammar are performed.
"""

import argparse
import glob
import os
import shutil
import subprocess
import tempfile  # for temporary directories

GRAMMARS = {
    "fstrips": "fstrips.g4",
}

CURRENT_DIR = os.path.dirname(os.path.realpath(__file__))


def parse_arguments():
    parser = argparse.ArgumentParser(description='Build parser for one of the available grammars')
    parser.add_argument('--grammar', default="fstrips", help='The grammar to generate. Currently accepted: {}'
                        .format(', '.join(GRAMMARS.keys())))
    args = parser.parse_args()

    args.grammar_filename = os.path.join(CURRENT_DIR, 'grammars', '{}.g4'.format(args.grammar))
    if not os.path.exists(args.grammar_filename):
        raise RuntimeError("Could not find expected grammar file '{0}'".format(args.grammar_filename))

    return args


def main():
    args = parse_arguments()

    tmpdir = run_antlr(args)

    target = create_target_package(args)

    # The files generated by ANTLR will be left in /tmp/grammars/*
    prefix = args.grammar
    pattern = os.path.join(tmpdir.name, "{}*.py".format(prefix))
    print("ANTLR finished running. Generated parser files expected to be at: {}".format(pattern))

    for name in glob.glob(pattern):
        process_antlr_file(name, prefix, target)


def process_antlr_file(name, prefix, target):
    target_filename = os.path.basename(name).replace(prefix, '').lower()
    dst = shutil.copy(name, os.path.join(target, target_filename))
    with(open(dst)) as instream:
        lines = instream.read()
    rules = [('from {}Parser'.format(prefix), 'from parser'),
             ('from .{}Parser'.format(prefix), 'from .parser'),
             ('from {}Listener'.format(prefix), 'from listener'),
             ('from .{}Listener'.format(prefix), 'from .listener'),
             ('from {}Visitor'.format(prefix), 'from visitor'),
             ('from .{}Visitor'.format(prefix), 'from .visitor'),
             ('from {}Lexer'.format(prefix), 'from lexer'),
             ('from .{}Lexer'.format(prefix), 'from .lexer')
             ]
    for old, new in rules:
        lines = lines.replace(old, new)
    with open(dst, 'w') as outstream:
        outstream.write(lines)
    print("Generated and processed file '{}'".format(dst))


def create_target_package(args):
    # This path is likely to require manual adjustments, but no need to worry too much about this
    source_tree = os.path.realpath(os.path.join(CURRENT_DIR, "..", "..", "src", "tarski", "io"))
    target = os.path.join(source_tree, "_{}".format(args.grammar), "parser")
    os.makedirs(target, exist_ok=True)
    open(os.path.join(target, '__init__.py'), 'a').close()  # i.e. create the __init__.py file
    print("Created parser module at '{}'".format(target))
    return target


def run_antlr(args):
    tmpdir = tempfile.TemporaryDirectory()
    command = ('java -Xmx500M org.antlr.v4.Tool -visitor -Dlanguage=Python3 -o {} {}'.
               format(tmpdir.name, args.grammar_filename))

    try:
        print("Executing: {}".format(command))
        subprocess.check_output(command, shell=True)
    except Exception:
        raise RuntimeError("Could not execute ANTLR. Make sure it is correctly installed and the environment variable "
                           "'ANTLR_PATH' points at the ANTLR jar file. Command:\n{}".format(command)) from None
    return tmpdir


if __name__ == '__main__':
    main()
